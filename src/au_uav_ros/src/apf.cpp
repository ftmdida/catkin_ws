/*
Implementation of force.h.  For comments on how to use these functions, visit force.h.  Comments in this file
are related to implementation, not usage.
*/

#include <math.h>
#include <stdlib.h>
#include <vector>
#include <algorithm>

#include "au_uav_ros/apf.h"
#include "au_uav_ros/standardFuncs.h"		// for PI, EARTH_RADIUS, MPS_SPEED

//TODO: get the simplaneobject include working
#define MAXIMUM_TURNING_ANGLE 22.5 //degrees
//#include "au_uav_ros/simPlaneObject.h"		// for MAXIMUM_TURNING_ANGLE
#define EPSILON 1e-4						// used to check floating point numbers for equality
#define LOOPING_DISTANCE 4*MPS_SPEED		// When distance to destination is less than this distance, we should start checking for looping
#define LOOP_RADIUS 28.64058013			// Turning radius of the UAV = MPS_SPEED/sin(MAXIMUM_TURNING_ANGLE)*sin((180-MAXIMUM_TURNING_ANGLE)/2)
						// Because the simulator assumes straight turns, we used the law of sines to find the distance from the
						// points on the perimeter of the hexadecagon generated by a looping UAV to the center of hexadecagon

#define DEST_CHARGE 100 			//Amount of positive charge given to a destination waypoint.
#define PRIORITY_DISTANCE 50 		//How close a plane must be to its destination to become considered for having priority (in meters).
#define FRONT_FEEL 1.0 				//The percent of calculated charge a plane will feel from the front (pushing plane "backwards")
#define	BACK_FEEL 0.5 				//The percent of calculated charge a plane will feel from the back (pushing plane "forwards")


#define CHATTERING_ANGLE 30.0 //degrees
#define SECOND_THRESHOLD 1.50*MPS_SPEED //meters
#define PLANE_MAX_TURN_ANGLE 22.5 //degrees / sec
#define CHECK_ZONE 10.0*MPS_SPEED //meters
#define DANGER_ZEM 3.5*MPS_SPEED //meters
#define MINIMUM_TURNING_RADIUS 28.64058013 //meters
#define DESIRED_SEPARATION 2.5*MPS_SPEED //meters
#define LAMBDA 0.1 //dimensionless
#define TIME_STEP 1.0 //seconds
#define MINIMUM_TIME_TO_GO 100.0 //seconds
#define MAXIMUM_TURNING_ANGLE 22.5
#define MPS_WAYPOINT_MULTIPLIER	2


au_uav_ros::forceVariables forceVars;		// stores the force variables from a document of parameters

/* arrays of parameters used depending on the scenario */
//maxForce, alpha, beta, gamma, alphaTop, betaTop, betaBot, alphaTopF, betaTopF

double param_4plane_500m [] = {6000, 0.00008, 0.00050, 1500, 0.25, 0.01, 1, 0.25, 0.1};
double param_4plane_1000m [] = {6000, 0.00008, 0.00005, 1000, 0.25, 0.01, 1, 0.25, 0.1};
double param_8plane_500m [] = {6000, 0.00008, 0.00030, 1500, 0.25, 0.01, 1.2, 0.27, 0.1};
double param_8plane_1000m [] = {6000, 0.00008, 0.00005, 1000, 0.25, 0.01, 1, 0.25, 0.1};
double param_16plane_500m [] = {6000, 0.00008, 0.00010, 1000, 0.25, 0.01, 1, 0.25, 0.1};
double param_16plane_1000m [] = {6000, 0.00008, 0.0001, 1000, 0.25, 0.01, 1, 0.25, 0.1};
double param_32plane_500m [] = {6000, 0.00008, 0.00005, 1000, 0.25, 0.01, 1, 0.25, 0.1};
double param_32plane_1000m [] = {6000, 0.00008, 0.0001, 1000, 0.25, 0.01, 1, 0.25, 0.1};

double destLatArray [32];			// keep track of waypoints to help determine field size
double destLonArray [32];


/*This function is called in collisionAvoidance.cpp and utilizes the other 
	functions outlined in this file to calculate a collision avoidance waypoint 
	for the plane to travel to. If no collision avoidance or maneuvering is 
	necessary, this functions returns the current destination waypoint */
	au_uav_ros::waypoint au_uav_ros::findNewAPFWaypoint(PlaneObject &plane1, std::map<int, PlaneObject> &planes) {
		


	/* Find plane to avoid*/
	au_uav_ros::threatContainer greatestThreat = findGreatestThreat(plane1, planes);
	
	/* Unpack plane to avoid*/	
	int threatID = greatestThreat.planeID;
	double threatZEM = greatestThreat.ZEM;
	double timeToGo = greatestThreat.timeToGo;
	/*
	if (threatID != -1) {
	ROS_WARN("Distance between plane %d and plane %d = %f", plane1.getID(), 
		threatID, findDistance(plane1.getCurrentLoc().latitude, 
		plane1.getCurrentLoc().longitude, planes[threatID].getCurrentLoc().latitude, 
		planes[threatID].getCurrentLoc().longitude));
	}
	*/

	au_uav_ros::waypoint newWP; 	

	/* If there is no plane to avoid, then take Dubin's path to the 
	destination waypoint*/
	if (((threatID < 0) && (threatZEM < 0)) || timeToGo > MINIMUM_TIME_TO_GO) {
		return takeDubinsPath(plane1);
	}

	//NOTE: setupForceVars might should be called before this method is called the first time.

	setupForceVars(planes);

	int planeID = plane1.getID();
	
	/* Find the force acting on this UAV.  The plane is attracted to its waypoint or leader, and repelled from other UAVs */
	au_uav_ros::mathVector force = calculateForces(planes[planeID], planes, forceVars);
	
	return updatePath(plane1, force);
}

/* This function is calculates any maneuvers that are necessary for the 
current plane to avoid looping. Returns a waypoint based on calculations. 
If no maneuvers are necessary, then the function returns the current 
destination*/
au_uav_ros::waypoint au_uav_ros::takeDubinsPath(PlaneObject &plane1) {
	/* Initialize variables*/
	au_uav_ros::coordinate circleCenter;
	au_uav_ros::waypoint wp = plane1.getDestination();
	double minTurningRadius = 0.75*MINIMUM_TURNING_RADIUS;
	bool destOnRight;
	/* Calculate cartesian angle from plane to waypoint*/
	double wpBearing = findAngle(plane1.getCurrentLoc().latitude, 
		plane1.getCurrentLoc().longitude, wp.latitude, wp.longitude);
	/* Calculate cartesian current bearing of plane (currentBearing is stored as Cardinal)*/
	double currentBearingCardinal = toCardinal(plane1.getCurrentBearing());	
	double currentBearingCartesian = plane1.getCurrentBearing();
	
	
	if (fabs(currentBearingCardinal) < 90.0)
	/* Figure out which side of the plane the waypoint is on*/		
		if ((wpBearing < currentBearingCartesian) && 
				(wpBearing > manipulateAngle(currentBearingCartesian - 180.0)))
			destOnRight = true;
		else destOnRight = false;
	else
		if ((wpBearing > currentBearingCartesian) && 
				(wpBearing < manipulateAngle(currentBearingCartesian - 180.0)))
			destOnRight = false;
		else destOnRight = true;
	/* Calculate the center of the circle of minimum turning radius on the side that the waypoint is on*/
	
	circleCenter = calculateLoopingCircleCenter(plane1, minTurningRadius, destOnRight);

	/* If destination is inside circle, must fly opposite direction before we can reach destination*/
	if (findDistance(circleCenter.latitude, circleCenter.longitude, wp.latitude, wp.longitude) < 
			minTurningRadius) {
		return calculateWaypoint(plane1, minTurningRadius, !destOnRight);
	}
	else {
		//we can simply pass the current waypoint because it's accessible
		//ROS_WARN("FINE: %f", findDistance(circleCenter.latitude, circleCenter.longitude, wp.latitude, wp.longitude));
		return wp;
	}
}

/* Function that returns the ID of the most dangerous neighboring plane and its ZEM */
au_uav_ros::threatContainer au_uav_ros::findGreatestThreat(PlaneObject &plane1, std::map<int, PlaneObject> &planes){
	/* Set reference for origin (Northwest corner of the course)*/
	au_uav_ros::coordinate origin;
	origin.latitude = 32.606573;
	origin.longitude = -85.490356;
	origin.altitude = 400;
	/* Set preliminary plane to avoid as non-existent and most dangerous 
	ZEM as negative*/
	int planeToAvoid = -1;
	double mostDangerousZEM = -1;
	
	/* Set the preliminary time-to-go to infinity*/
	double minimumTimeToGo = std::numeric_limits<double>::infinity();
	/* Declare second plane and ID variable */
	PlaneObject plane2;
	int ID;
	/* Make a position vector representation of the current plane*/
	double magnitude2, direction2;
	double magnitude = findDistance(origin.latitude, origin.longitude, 
		plane1.getCurrentLoc().latitude, plane1.getCurrentLoc().longitude);
	double direction = findAngle(origin.latitude, origin.longitude, 
		plane1.getCurrentLoc().latitude, plane1.getCurrentLoc().longitude);
	au_uav_ros::mathVector p1(magnitude,direction);

	/* Make a heading vector representation of the current plane*/
	au_uav_ros::mathVector d1(1.0,plane1.getCurrentBearing());
	
	/* Declare variables needed for this loop*/
	au_uav_ros::mathVector pDiff;
	au_uav_ros::mathVector dDiff;
	double timeToGo, zeroEffortMiss, distanceBetween, timeToDest;
	std::map<int,au_uav_ros::PlaneObject>::iterator it;
	for ( it=planes.begin() ; it!= planes.end(); it++ ){
		/* Unpacking plane to check*/		
		ID = (*it).first;
		plane2 = (*it).second;
		
		/* If it's not in the Check Zone, check the other plane*/
		distanceBetween = plane1.findDistance(plane2);
		if (distanceBetween > CHECK_ZONE || plane1.getID() == ID) continue;

		// md
		if (distanceBetween > 0 && distanceBetween < COLLISION_THRESHOLD) {
			// ROS_ERROR("Distance between #%d and %d is: %f",
				// plane1.getID(), plane2.getID(), distanceBetween);
		}

		else if (distanceBetween < MPS_SPEED) {
			planeToAvoid = ID;
			mostDangerousZEM = 0;
			minimumTimeToGo = 0.1;
			break;
		}	

		/* Making a position vector representation of plane2*/
		magnitude2 = findDistance(origin.latitude, origin.longitude, 
			plane2.getCurrentLoc().latitude, plane2.getCurrentLoc().longitude);
		direction2 = findAngle(origin.latitude, origin.longitude, 
			plane2.getCurrentLoc().latitude, plane2.getCurrentLoc().longitude);
		au_uav_ros::mathVector p2(magnitude2,direction2);

		/* Make a heading vector representation of the current plane*/
		au_uav_ros::mathVector d2(1.0,plane2.getCurrentBearing());

		/* Compute Time To Go*/
		pDiff = p1-p2;
		dDiff = d1-d2;
		timeToGo = -1*pDiff.dotProduct(dDiff)/(MPS_SPEED*dDiff.dotProduct(dDiff));

		/* Compute Zero Effort Miss*/
		zeroEffortMiss = sqrt(pDiff.dotProduct(pDiff) + 
			2*(MPS_SPEED*timeToGo)*pDiff.dotProduct(dDiff) + 
			pow(MPS_SPEED*timeToGo,2)*dDiff.dotProduct(dDiff));
		
		/* If the Zero Effort Miss is less than the minimum required 
		separation, and the time to go is the least so far, then avoid this plane*/
		if(zeroEffortMiss <= DANGER_ZEM && timeToGo < minimumTimeToGo && timeToGo > 0){
			// If the plane is behind you, don't avoid it
			if ( fabs(plane2.findAngle(plane1)*180/PI - plane1.getCurrentBearing()) > 35.0) {
				timeToDest = plane1.findDistance(plane1.getDestination().latitude, 
					plane1.getDestination().longitude) / MPS_SPEED;
				/* If you're close to your destination and the other plane isn't
				much of a threat, then don't avoid it */ 
				if ( timeToDest < 5.0 && zeroEffortMiss > 3.0*MPS_SPEED ) continue;
				planeToAvoid = ID;
				mostDangerousZEM = zeroEffortMiss;
				minimumTimeToGo = timeToGo;			
			}
		}
	}

	au_uav_ros::threatContainer greatestThreat;
	greatestThreat.planeID = planeToAvoid;
	greatestThreat.ZEM = mostDangerousZEM;
	greatestThreat.timeToGo = minimumTimeToGo;

	return greatestThreat;
}

au_uav_ros::coordinate au_uav_ros::calculateLoopingCircleCenter(PlaneObject &plane, double turnRadius, bool turnRight) {
	au_uav_ros::coordinate circleCenter;
	circleCenter.altitude = plane.getCurrentLoc().altitude;
	double angle;
	if (turnRight) {
		angle = (plane.getCurrentBearing() - 90 - 22.5) * PI/180.0; 
	}
	else {
		angle = (plane.getCurrentBearing() + 90 + 22.5) * PI/180.0;
	}
	double xdiff = turnRadius*cos(angle);
	double ydiff = turnRadius*sin(angle);
	circleCenter.longitude = plane.getCurrentLoc().longitude + xdiff/DELTA_LON_TO_METERS;
	circleCenter.latitude = plane.getCurrentLoc().latitude + ydiff/DELTA_LAT_TO_METERS; 

	return circleCenter;
}

/* Find the new collision avoidance waypoint for the plane to go to */
au_uav_ros::waypoint au_uav_ros::calculateWaypoint(PlaneObject &plane1, double turningRadius, bool turnRight){

	au_uav_ros::waypoint wp;	
	double V = MPS_SPEED * MPS_WAYPOINT_MULTIPLIER;
	double delta_T = TIME_STEP;	
	double cartBearing = plane1.getCurrentBearing()* PI/180;
	double delta_psi = V / turningRadius * delta_T;
	if (turnRight) delta_psi *= -1.0;
	ROS_WARN("Delta psi: %f", delta_psi);
	double psi = (cartBearing + delta_psi);
	V = V * MPS_WAYPOINT_MULTIPLIER;
	wp.longitude = plane1.getCurrentLoc().longitude + V*cos(psi)/DELTA_LON_TO_METERS;
	wp.latitude = plane1.getCurrentLoc().latitude + V*sin(psi)/DELTA_LAT_TO_METERS;
	ROS_INFO("long+%f, lat+%f, distanceBetween UAV and AvoidWP%f", V*cos(psi)/DELTA_LON_TO_METERS, V*sin(psi)/DELTA_LON_TO_METERS,
		distanceBetween(plane1.getCurrentLoc(), wp));
	wp.altitude = plane1.getCurrentLoc().altitude;
	ROS_WARN("Plane%d new cbearing: %f", plane1.getID(), toCardinal( findAngle(plane1.getCurrentLoc().latitude, plane1.getCurrentLoc().longitude, wp.latitude, wp.longitude) ) ); 
	//ROS_WARN("Plane%d calc lat: %f lon: %f w/ act lat: %f lon: %f", plane1.getID(), wp.latitude, wp.longitude, plane1.getCurrentLoc().latitude, plane1.getCurrentLoc().longitude);
	
	return wp;
}


au_uav_ros::waypoint au_uav_ros::updatePath(const PlaneObject &plane1, au_uav_ros::mathVector forceVector){
	double forceTheta = forceVector.getDirection(); /* angle of the force vector with respect to North bearing */
	double d = MPS_SPEED/EARTH_RADIUS; /* angular distance traveled in one second */

	au_uav_ros::waypoint currentPosition, newPosition;
	currentPosition.latitude = plane1.getCurrentLoc().latitude;
	currentPosition.longitude = plane1.getCurrentLoc().longitude;
	currentPosition.altitude = plane1.getCurrentLoc().altitude;

	newPosition = calculateCoordinate(currentPosition, forceTheta, d);	/* find new position one second away based on direction of force */
	newPosition.planeID = plane1.getID();
	return newPosition;
}

	void au_uav_ros::setupForceVars(std::map<int, PlaneObject> &planes) {
		int fieldSize = 500;
		int numberOfPlanes = planes.size();

// check the positions of all the waypoints and planes to see the field size for the correct parameters
	// it IS possible for a larger scenario to seem like a smaller scenario by chance, but that should be okay
		for (std::map<int, au_uav_ros::PlaneObject>::iterator iter = planes.begin(); iter != planes.end(); iter++){
        		PlaneObject currentPlane = iter->second;
			// check waypoints
			if (destLatArray[currentPlane.getID()] < (SOUTH_MOST_LATITUDE_500M - LATITUDE_EPSILON) ||
			destLonArray[currentPlane.getID()] > (EAST_MOST_LONGITUDE_500M + LONGITUDE_EPSILON))			
			{
				fieldSize = 1000;
				break;
			}
		}
		
		// use the plane and waypoint information to find the correct parameters (update once per cycle)
		if (fieldSize == 500){
			if (numberOfPlanes <= 4){
				setupVariables(param_4plane_500m);
			}
			else if (numberOfPlanes <= 8){
				setupVariables(param_8plane_500m);
			}
			else if (numberOfPlanes <= 16){
				setupVariables(param_16plane_500m);
			}
			else if (numberOfPlanes <= 32){
				setupVariables(param_32plane_500m);
			}
			else
			{
				std::cout << "plane number error: more than 32 UAVs found- using 32 plane case" << std::endl;
				setupVariables(param_32plane_500m);
			}
		}
	
		else if (fieldSize == 1000){
			if (numberOfPlanes <= 4){
				setupVariables(param_4plane_1000m);
			}
			else if (numberOfPlanes <= 8){
				setupVariables(param_8plane_1000m);
			}
			else if (numberOfPlanes <= 16){
				setupVariables(param_16plane_1000m);
			}
			else if (numberOfPlanes <= 32){
				setupVariables(param_32plane_1000m);
			}
			else
			{
				setupVariables(param_32plane_1000m);
				std::cout << "plane number error: more than 32 UAVs found- using 32 plane case" << std::endl;
			}
		}
		
		else std::cout << "field size error: invalid field size determined (this should never happen)" << std::endl;

		std::cout << "Using parameters for a " << fieldSize << "m field and " << numberOfPlanes << " UAVs" << std::endl;
	}
			
		

void au_uav_ros::setupVariables(double currentParam [9]){
	forceVars.maxForce = currentParam[0];
	forceVars.alpha = currentParam[1];
	forceVars.beta = currentParam[2];
	forceVars.gamma = currentParam[3];
	forceVars.alphaTop = currentParam[4];
	forceVars.betaTop = currentParam[5];
	forceVars.betaBot = currentParam[6];
	forceVars.alphaTopF = currentParam[7];
	forceVars.betaTopF = currentParam[8];
	
	forceVars.alphaBot = forceVars.alphaTop;
	forceVars.alphaBotF = forceVars.alphaTopF;
	forceVars.betaBotF = forceVars.betaBot;
}


/*
The calculateForces method is the primary method in the force.cpp file.  Calling this
method will result in subsequent calls to all other methods in this file.  
*/
au_uav_ros::mathVector au_uav_ros::calculateForces(PlaneObject &pobj1, std::map<int, PlaneObject> &pobjects, au_uav_ros::forceVariables forceVars){
	double distance = 0.0, rAngle = 0.0, fieldAngle = 0.0, maxDistance = 0.0;
	mathVector rForce(0.0, 0.0), aForce(0.0, 0.0), tForce(1.0, 0.0), aForceUnit(0.0, 0.0), rForceUnit(0.0, 0.0);

	//calculate the attraction force
	aForce = calculateAttractionForce(pobj1);

    for (std::map<int, au_uav_ros::PlaneObject>::iterator iter = pobjects.begin(); iter != pobjects.end(); iter++){
        PlaneObject currentPlane = iter->second;
        
        mathVector rToBearing(0.0, 0.0);
			double distToDest = distanceBetween(currentPlane.getCurrentLoc(), currentPlane.getDestination());
			if(currentPlane.getID() == pobj1.getID() && distToDest < PRIORITY_DISTANCE){
				//This plane has priority over the rest so we don't need to calculate further forces.
				break;
			}

			else if(currentPlane.getID() == pobj1.getID()){
				//these are the same plane...do nothing
			}
			else{
				    //find angle between the bearing of currentPlane and pobj1
					fieldAngle = manipulateAngle(currentPlane.findAngle(pobj1) - currentPlane.getCurrentBearing());
		
					//find angle of repulsive force with respect to Cartesian coordinates
					rAngle = toCartesian(pobj1.findAngle(currentPlane) - 180);

					// find distance between pobj1 and currentPlane
					distance = pobj1.findDistance(currentPlane);
					
					// find the force
					mathVector currentForce = calculateRepulsionForce(pobj1, distance, maxDistance, rAngle, fieldAngle, aForce.getDirection(), forceVars);
					
					//Calculates angle between pobj1's bearing and the direction of repulsion force.
					//rToBearing = manipulateAngle(toCartesian(pobj1.getCurrentBearing()) - rAngle);
					
                    rForce += currentForce;
				}
			}
	
	//Get unit vectors for forces
	aForceUnit = aForce;
	aForceUnit.setMagnitude(1);

	rForceUnit = rForce;
	if(rForceUnit.getMagnitude() > 0)
		rForceUnit.setMagnitude(1);

	//Use unit vectors to fix head on collisions
	if ((aForceUnit + rForceUnit).getMagnitude() < EPSILON){
		//give the planes a "nudge" to the right to break deadlock
		double newDirection = manipulateAngle(aForce.getDirection() - 15);

		tForce.setDirection(newDirection);
	}
	else{
		//calculate total force
		tForce = aForce + rForce;

		//Check to see if this total force will put plane in a loop
		if (inLoop(pobj1, tForce)){ 
			//pobj1 is in a loop, modify attractive force so that the destination is actually repulsive to break the cycle
			aForce.setDirection(manipulateAngle(aForce.getDirection() + 180));
			
			//we changed aForce so now need to recalculate tForce
			tForce = aForce + rForce;
		}
		
		//Make sure resulting force angle does not exceed turning angle of plane
		makeForceViable(pobj1, tForce);
	}
	return tForce;
}

/*
Calculates the repulsion force between two planes.
The distance parameter is the distance between the planes in meters, maxDistance is
the distance over which field pobj1 is in acts, rAngle is the angle of the repulsive force, 
fieldAngle is the angle between the bearing of the plane generating the force to the location
of pobj1, and aAngle is the angle between the bearing of pobj1 and the location of its destination.
All angles are in the Cartesian plane.
*/
au_uav_ros::mathVector au_uav_ros::calculateRepulsionForce(const PlaneObject &pobj1, double distance, 
							double maxDistance, double rAngle, double fieldAngle, double aAngle, au_uav_ros::forceVariables forceVars){
	double rForce = 0.0, rToBearing = 0.0;

	//If getting close to conflict zone, max repulsion.
	if(distance <= 2.5*MPS_SPEED){
		rForce = 99999;
	}else{
		//calculates the repulsive force emitted from other plane based on fieldAngle from which pobj1 is approaching
		//and whether the plane is a follower in a swarm
		//fieldAngle is in degrees

		bool activateForce = false;
	
		//find the difference in x and y based on field-generating plane's POV
		double y = distance*cos(fieldAngle * PI / 180);
		double x = distance*sin(fieldAngle * PI / 180);


			//find the limits of the APF field- the constants here are part of the egg shape
			//figure out if self is within the limit of the force field
			if (fieldAngle > 90 && fieldAngle <270){
				// plane generating the force is behind, therefore use the bottom boundary	
				double forceLimit = -sqrt((forceVars.gamma-(forceVars.alphaBot*pow(x,2)))/forceVars.betaBot);
				if (y>forceLimit) activateForce = true;
			}
			else{
				// plane generating the force is in front, therefore use the top boundary
				double forceLimit = sqrt((forceVars.gamma-(forceVars.alphaTop*pow(x,2)))/forceVars.betaTop);
				if (y<forceLimit) activateForce = true;
			}
		
		
	
		if (activateForce) rForce = forceVars.maxForce * exp(-forceVars.alpha*pow(x,2)-forceVars.beta*pow(y,2));
		else rForce = 0;
	}

	//Calculates angle between pobj1's bearing and the direction of repulsion force.
	rToBearing = manipulateAngle(toCartesian(pobj1.getCurrentBearing()) - rAngle);
	
	
	//Right hand rule
	//Determines if a plane should be forced to make a right turn to travel behind a plane approaching from the right.
	
	if(fieldAngle < 0 && fieldAngle > -135 && rToBearing < -90 && rToBearing > -180){
		double a = 0.0, b = 0.0, c = 0.0, A = 0.0, B = 0.0, C = 0.0;
		
		//Spherical law of cosines calculations
		
		if(fieldAngle > -25){
			a = distance / EARTH_RADIUS;
			B = -1 * fieldAngle * PI / 180;
			C = (180 - (-1 * rToBearing)) * PI / 180;

			A = acos(-cos(B)*cos(C) + sin(B)*sin(C)*cos(a));

			b = acos((cos(B) + cos(C)*cos(A))/(sin(C)*sin(A)));
			b *= EARTH_RADIUS;

			c = acos((cos(C) + cos(A)*cos(B))/(sin(A)*sin(B)));
			c *= EARTH_RADIUS;
		}

		//Angle between bearing and destination
		double aToBearing = manipulateAngle(toCartesian(pobj1.getCurrentBearing()) - aAngle);

		if((c - b) > ((-1 * rToBearing) - 90.0) && fieldAngle > -25){
			//Plane should not turn right, because it will turn into a plane
		}else if(aToBearing < 0 && fieldAngle < -90){
			//Plane should not turn right, parallel to other plane and its destination is to the left
		}else{
			//flip repulsive force across bearing to force right turn.
			rAngle = manipulateAngle(2 * (180 + rToBearing) + rAngle);
		}
	}	
	
	//calculates force felt by pobj1 based on angle, rToBearing, at which the force is applied.
	rForce = rForce * ((FRONT_FEEL-((FRONT_FEEL-BACK_FEEL)/2)) + (-0.5*(FRONT_FEEL-BACK_FEEL)) * cos(rToBearing * PI / 180));

	mathVector mV(rForce, rAngle);
	return mV;
}

/*
Calculates the direction the plane needs to head in order to reach destination
point, and sets the magnitude of this attractive force to the DEST_CHARGE.
If the plane is a follower in a swarm, it will head towards its leader.
*/
au_uav_ros::mathVector au_uav_ros::calculateAttractionForce(const PlaneObject &pobj1){
	double aForce = 0.0, aAngle = 0.0;

    //Find angle of attractive force and convert the angle from cardinal to cartesian
    aAngle = toCartesian(findAngle(pobj1.getCurrentLoc().latitude, pobj1.getCurrentLoc().longitude,
						pobj1.getDestination().latitude, pobj1.getDestination().longitude));
	

	//Attractive force is constant (we want the plane to always be attracted by its destination)
	mathVector mV(DEST_CHARGE, aAngle);
	return mV;
}

/* 
Modifies the total force acting on pobj1 so that the new path does not differ more than 22.5 degrees from the current 
bearing.
*/
void au_uav_ros::makeForceViable(PlaneObject &pobj1, mathVector &tForce){
	//angle of UAV bearing in degrees w/ respect to cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getCurrentBearing());

	//Find angle between force vector and UAV
	double deltaTheta = tForce.getDirection() - UAVTheta;

	//Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);

	//Only allow turns of 22.5 degrees maximum
	if (deltaTheta > MAXIMUM_TURNING_ANGLE){
		deltaTheta = MAXIMUM_TURNING_ANGLE;
	}
	else if (deltaTheta < -MAXIMUM_TURNING_ANGLE){
		deltaTheta = -MAXIMUM_TURNING_ANGLE;
	}
	
	deltaTheta += UAVTheta;

	// Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);				

	tForce.setDirection(toCardinal(deltaTheta));
}

/* 
Method determines if aircraft is making a maximum angle turn and is within looping distance of its destination.
If so, it finds the distance between the destination of the UAV and the center of the circle made by a looping UAV,
and determines if the destination is unreachable.
*/
bool au_uav_ros::inLoop(const PlaneObject &pobj1, mathVector &tForce){
	bool inLoop = false;
	//angle of actual UAV bearing in degrees w/ respect to cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getCurrentBearing());
	double distanceToDest = findDistance(pobj1.getCurrentLoc().latitude, pobj1.getCurrentLoc().longitude, pobj1.getDestination().latitude, pobj1.getDestination().longitude);

	//Find angle between force vector and UAV
	double deltaTheta = tForce.getDirection() - UAVTheta;

	//Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);

	//Check to see if attempting a maximum turn
	if (deltaTheta > MAXIMUM_TURNING_ANGLE){
		//Check for looping
		if (distanceToDest < LOOPING_DISTANCE){
			// find distance between center of "circle" made when the UAV is looping and the destination
			double centerToWaypoint = findLoopDistance(pobj1,101.25);	

			//if the centerToWaypoint distance is less than LOOP_RADIUS-COLLISION_THRESHOLD, destination will not be reached
			if(centerToWaypoint < (LOOP_RADIUS-COLLISION_THRESHOLD)){
				inLoop = true;
			}else{
				inLoop = false;
			}
		}
	}
	
	//Check to see if attempting a maximum turn
 	 if(deltaTheta < -MAXIMUM_TURNING_ANGLE){
		//Check for looping
		if (distanceToDest < LOOPING_DISTANCE){
			// find distance between center of "circle" made when the UAV is looping and the destination
			double centerToWaypoint = findLoopDistance(pobj1,-101.25);

			//if the centerToWaypoint distance is less than LOOP_RADIUS-COLLISION_THRESHOLD, destination will not be reached
			if(centerToWaypoint < (LOOP_RADIUS-COLLISION_THRESHOLD)){
				inLoop = true;
			}else{
				inLoop = false;
			}
		}
	}
	return inLoop;
}

/*
Calculates the distance between the center of "circle" generated when a plane is looping around its destination
and the plane's destination.  The angle parameter is the number of degrees to the left or right of the UAV the center of
turning is located.  The angle parameter is based off of the turning angle per second.  Because the simulator
uses straight line paths between each of the waypoints given, a looping UAV actually creates a hexadecagon.  
For example, in this code 22.5 is our turning angle. Therefore, the angle provided for this method is either 101.25 or -101.25 since 
[(180-22.5)/2 = 78.75; 78.75 + 22.5 = 101.25].
*/
double au_uav_ros::findLoopDistance(const PlaneObject &pobj1, double angle){
	//actual bearing of plane in cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getCurrentBearing());
	//Angle from bearing of plane to center of turning radius circle in cardinal coordinates.
	double bearingToCenter = toCardinal(manipulateAngle(UAVTheta+angle));

	//angular distance to center of the "circle" generated by a looping UAV
	double distToCenter = LOOP_RADIUS/EARTH_RADIUS;

	//current position of plane
	au_uav_ros::waypoint position;
	position.latitude = pobj1.getCurrentLoc().latitude;
	position.longitude = pobj1.getCurrentLoc().longitude;
	position.altitude = pobj1.getCurrentLoc().altitude;

	//calculate location of the center of the "circle" generated by a looping UAV
	au_uav_ros::waypoint centerPosition = calculateCoordinate(position, bearingToCenter, distToCenter);

	//distance between center and destination
	double centerToWaypoint = distanceBetween(centerPosition, 
					pobj1.getDestination());
	
	return centerToWaypoint;
}
